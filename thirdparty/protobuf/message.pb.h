// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace HoneyClient {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_message_2eproto();
void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class Message;
class Message_Client;
class Message_File;
class Message_File_Content;
class Message_Registry;
class Message_Process;
class Message_Fingerprint;
class Message_Url;
class Message_Job;
class Message_Firewall;
class Message_Firewall_Command;

enum Message_Url_Status {
  Message_Url_Status_NOT_VISITED = 1,
  Message_Url_Status_VISITED = 2,
  Message_Url_Status_IGNORED = 3,
  Message_Url_Status_TIMED_OUT = 4,
  Message_Url_Status_ERROR = 5,
  Message_Url_Status_SUSPICIOUS = 6
};
const ::google::protobuf::EnumDescriptor* Message_Url_Status_descriptor();
bool Message_Url_Status_IsValid(int value);
const Message_Url_Status Message_Url_Status_Status_MIN = Message_Url_Status_NOT_VISITED;
const Message_Url_Status Message_Url_Status_Status_MAX = Message_Url_Status_SUSPICIOUS;

enum Message_Firewall_Command_ActionType {
  Message_Firewall_Command_ActionType_UNKNOWN = 1,
  Message_Firewall_Command_ActionType_DENY_ALL = 2,
  Message_Firewall_Command_ActionType_DENY_VM = 3,
  Message_Firewall_Command_ActionType_ALLOW_VM = 4,
  Message_Firewall_Command_ActionType_ALLOW_ALL = 5
};
const ::google::protobuf::EnumDescriptor* Message_Firewall_Command_ActionType_descriptor();
bool Message_Firewall_Command_ActionType_IsValid(int value);
const Message_Firewall_Command_ActionType Message_Firewall_Command_ActionType_ActionType_MIN = Message_Firewall_Command_ActionType_UNKNOWN;
const Message_Firewall_Command_ActionType Message_Firewall_Command_ActionType_ActionType_MAX = Message_Firewall_Command_ActionType_ALLOW_ALL;

enum Message_Firewall_Command_ResponseType {
  Message_Firewall_Command_ResponseType_ERROR = 1,
  Message_Firewall_Command_ResponseType_OK = 2
};
const ::google::protobuf::EnumDescriptor* Message_Firewall_Command_ResponseType_descriptor();
bool Message_Firewall_Command_ResponseType_IsValid(int value);
const Message_Firewall_Command_ResponseType Message_Firewall_Command_ResponseType_ResponseType_MIN = Message_Firewall_Command_ResponseType_ERROR;
const Message_Firewall_Command_ResponseType Message_Firewall_Command_ResponseType_ResponseType_MAX = Message_Firewall_Command_ResponseType_OK;

// ===================================================================

class Message_Client : public ::google::protobuf::Message {
 public:
  Message_Client();
  virtual ~Message_Client();
  
  Message_Client(const Message_Client& from);
  
  inline Message_Client& operator=(const Message_Client& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Client& default_instance();
  void Swap(Message_Client* other);
  
  // implements Message ----------------------------------------------
  
  Message_Client* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Client& from);
  void MergeFrom(const Message_Client& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string vm_name = 1;
  inline bool has_vm_name() const;
  inline void clear_vm_name();
  inline const ::std::string& vm_name() const;
  inline void set_vm_name(const ::std::string& value);
  inline void set_vm_name(const char* value);
  inline ::std::string* mutable_vm_name();
  
  // required string snapshot_name = 2;
  inline bool has_snapshot_name() const;
  inline void clear_snapshot_name();
  inline const ::std::string& snapshot_name() const;
  inline void set_snapshot_name(const ::std::string& value);
  inline void set_snapshot_name(const char* value);
  inline ::std::string* mutable_snapshot_name();
  
  // optional string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline ::std::string* mutable_status();
  
  // optional string start_at = 4;
  inline bool has_start_at() const;
  inline void clear_start_at();
  inline const ::std::string& start_at() const;
  inline void set_start_at(const ::std::string& value);
  inline void set_start_at(const char* value);
  inline ::std::string* mutable_start_at();
  
  // optional string compromise_at = 5;
  inline bool has_compromise_at() const;
  inline void clear_compromise_at();
  inline const ::std::string& compromise_at() const;
  inline void set_compromise_at(const ::std::string& value);
  inline void set_compromise_at(const char* value);
  inline ::std::string* mutable_compromise_at();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* vm_name_;
  static const ::std::string _default_vm_name_;
  ::std::string* snapshot_name_;
  static const ::std::string _default_snapshot_name_;
  ::std::string* status_;
  static const ::std::string _default_status_;
  ::std::string* start_at_;
  static const ::std::string _default_start_at_;
  ::std::string* compromise_at_;
  static const ::std::string _default_compromise_at_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Client* default_instance_;
};
// -------------------------------------------------------------------

class Message_File_Content : public ::google::protobuf::Message {
 public:
  Message_File_Content();
  virtual ~Message_File_Content();
  
  Message_File_Content(const Message_File_Content& from);
  
  inline Message_File_Content& operator=(const Message_File_Content& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_File_Content& default_instance();
  void Swap(Message_File_Content* other);
  
  // implements Message ----------------------------------------------
  
  Message_File_Content* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_File_Content& from);
  void MergeFrom(const Message_File_Content& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required string md5 = 2;
  inline bool has_md5() const;
  inline void clear_md5();
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline ::std::string* mutable_md5();
  
  // required string sha1 = 3;
  inline bool has_sha1() const;
  inline void clear_sha1();
  inline const ::std::string& sha1() const;
  inline void set_sha1(const ::std::string& value);
  inline void set_sha1(const char* value);
  inline ::std::string* mutable_sha1();
  
  // required string mime_type = 4;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline ::std::string* mutable_mime_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 size_;
  ::std::string* md5_;
  static const ::std::string _default_md5_;
  ::std::string* sha1_;
  static const ::std::string _default_sha1_;
  ::std::string* mime_type_;
  static const ::std::string _default_mime_type_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_File_Content* default_instance_;
};
// -------------------------------------------------------------------

class Message_File : public ::google::protobuf::Message {
 public:
  Message_File();
  virtual ~Message_File();
  
  Message_File(const Message_File& from);
  
  inline Message_File& operator=(const Message_File& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_File& default_instance();
  void Swap(Message_File* other);
  
  // implements Message ----------------------------------------------
  
  Message_File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_File& from);
  void MergeFrom(const Message_File& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_File_Content Content;
  
  // accessors -------------------------------------------------------
  
  // required string time_at = 1;
  inline bool has_time_at() const;
  inline void clear_time_at();
  inline const ::std::string& time_at() const;
  inline void set_time_at(const ::std::string& value);
  inline void set_time_at(const char* value);
  inline ::std::string* mutable_time_at();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required string event = 3;
  inline bool has_event() const;
  inline void clear_event();
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline ::std::string* mutable_event();
  
  // required .HoneyClient.Message.File.Content content = 4;
  inline bool has_content() const;
  inline void clear_content();
  inline const ::HoneyClient::Message_File_Content& content() const;
  inline ::HoneyClient::Message_File_Content* mutable_content();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* time_at_;
  static const ::std::string _default_time_at_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* event_;
  static const ::std::string _default_event_;
  ::HoneyClient::Message_File_Content* content_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_File* default_instance_;
};
// -------------------------------------------------------------------

class Message_Registry : public ::google::protobuf::Message {
 public:
  Message_Registry();
  virtual ~Message_Registry();
  
  Message_Registry(const Message_Registry& from);
  
  inline Message_Registry& operator=(const Message_Registry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Registry& default_instance();
  void Swap(Message_Registry* other);
  
  // implements Message ----------------------------------------------
  
  Message_Registry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Registry& from);
  void MergeFrom(const Message_Registry& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string time_at = 1;
  inline bool has_time_at() const;
  inline void clear_time_at();
  inline const ::std::string& time_at() const;
  inline void set_time_at(const ::std::string& value);
  inline void set_time_at(const char* value);
  inline ::std::string* mutable_time_at();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required string event = 3;
  inline bool has_event() const;
  inline void clear_event();
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline ::std::string* mutable_event();
  
  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline ::std::string* mutable_value();
  
  // optional string value_name = 6;
  inline bool has_value_name() const;
  inline void clear_value_name();
  inline const ::std::string& value_name() const;
  inline void set_value_name(const ::std::string& value);
  inline void set_value_name(const char* value);
  inline ::std::string* mutable_value_name();
  
  // optional string value_type = 7;
  inline bool has_value_type() const;
  inline void clear_value_type();
  inline const ::std::string& value_type() const;
  inline void set_value_type(const ::std::string& value);
  inline void set_value_type(const char* value);
  inline ::std::string* mutable_value_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* time_at_;
  static const ::std::string _default_time_at_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* event_;
  static const ::std::string _default_event_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* value_name_;
  static const ::std::string _default_value_name_;
  ::std::string* value_type_;
  static const ::std::string _default_value_type_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Registry* default_instance_;
};
// -------------------------------------------------------------------

class Message_Process : public ::google::protobuf::Message {
 public:
  Message_Process();
  virtual ~Message_Process();
  
  Message_Process(const Message_Process& from);
  
  inline Message_Process& operator=(const Message_Process& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Process& default_instance();
  void Swap(Message_Process* other);
  
  // implements Message ----------------------------------------------
  
  Message_Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Process& from);
  void MergeFrom(const Message_Process& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required uint64 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);
  
  // repeated .HoneyClient.Message.File file = 3;
  inline int file_size() const;
  inline void clear_file();
  inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_File >& file() const;
  inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_File >* mutable_file();
  inline const ::HoneyClient::Message_File& file(int index) const;
  inline ::HoneyClient::Message_File* mutable_file(int index);
  inline ::HoneyClient::Message_File* add_file();
  
  // repeated .HoneyClient.Message.Registry registry = 4;
  inline int registry_size() const;
  inline void clear_registry();
  inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Registry >& registry() const;
  inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Registry >* mutable_registry();
  inline const ::HoneyClient::Message_Registry& registry(int index) const;
  inline ::HoneyClient::Message_Registry* mutable_registry(int index);
  inline ::HoneyClient::Message_Registry* add_registry();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::uint64 pid_;
  ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_File > file_;
  ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Registry > registry_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Process* default_instance_;
};
// -------------------------------------------------------------------

class Message_Fingerprint : public ::google::protobuf::Message {
 public:
  Message_Fingerprint();
  virtual ~Message_Fingerprint();
  
  Message_Fingerprint(const Message_Fingerprint& from);
  
  inline Message_Fingerprint& operator=(const Message_Fingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Fingerprint& default_instance();
  void Swap(Message_Fingerprint* other);
  
  // implements Message ----------------------------------------------
  
  Message_Fingerprint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Fingerprint& from);
  void MergeFrom(const Message_Fingerprint& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .HoneyClient.Message.Process process = 1;
  inline int process_size() const;
  inline void clear_process();
  inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Process >& process() const;
  inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Process >* mutable_process();
  inline const ::HoneyClient::Message_Process& process(int index) const;
  inline ::HoneyClient::Message_Process* mutable_process(int index);
  inline ::HoneyClient::Message_Process* add_process();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Process > process_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Fingerprint* default_instance_;
};
// -------------------------------------------------------------------

class Message_Url : public ::google::protobuf::Message {
 public:
  Message_Url();
  virtual ~Message_Url();
  
  Message_Url(const Message_Url& from);
  
  inline Message_Url& operator=(const Message_Url& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Url& default_instance();
  void Swap(Message_Url* other);
  
  // implements Message ----------------------------------------------
  
  Message_Url* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Url& from);
  void MergeFrom(const Message_Url& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Url_Status Status;
  static const Status NOT_VISITED = Message_Url_Status_NOT_VISITED;
  static const Status VISITED = Message_Url_Status_VISITED;
  static const Status IGNORED = Message_Url_Status_IGNORED;
  static const Status TIMED_OUT = Message_Url_Status_TIMED_OUT;
  static const Status ERROR = Message_Url_Status_ERROR;
  static const Status SUSPICIOUS = Message_Url_Status_SUSPICIOUS;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Message_Url_Status_descriptor();
  }
  static inline bool Status_IsValid(int value) {
    return Message_Url_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Message_Url_Status_Status_MIN;
  static const Status Status_MAX =
    Message_Url_Status_Status_MAX;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required .HoneyClient.Message.Url.Status status = 2 [default = NOT_VISITED];
  inline bool has_status() const;
  inline void clear_status();
  inline ::HoneyClient::Message_Url_Status status() const;
  inline void set_status(::HoneyClient::Message_Url_Status value);
  
  // optional .HoneyClient.Message.Client client = 3;
  inline bool has_client() const;
  inline void clear_client();
  inline const ::HoneyClient::Message_Client& client() const;
  inline ::HoneyClient::Message_Client* mutable_client();
  
  // optional .HoneyClient.Message.Fingerprint fingerprint = 4;
  inline bool has_fingerprint() const;
  inline void clear_fingerprint();
  inline const ::HoneyClient::Message_Fingerprint& fingerprint() const;
  inline ::HoneyClient::Message_Fingerprint* mutable_fingerprint();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  int status_;
  ::HoneyClient::Message_Client* client_;
  ::HoneyClient::Message_Fingerprint* fingerprint_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Url* default_instance_;
};
// -------------------------------------------------------------------

class Message_Job : public ::google::protobuf::Message {
 public:
  Message_Job();
  virtual ~Message_Job();
  
  Message_Job(const Message_Job& from);
  
  inline Message_Job& operator=(const Message_Job& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Job& default_instance();
  void Swap(Message_Job* other);
  
  // implements Message ----------------------------------------------
  
  Message_Job* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Job& from);
  void MergeFrom(const Message_Job& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline ::std::string* mutable_uuid();
  
  // optional string created_at = 2;
  inline bool has_created_at() const;
  inline void clear_created_at();
  inline const ::std::string& created_at() const;
  inline void set_created_at(const ::std::string& value);
  inline void set_created_at(const char* value);
  inline ::std::string* mutable_created_at();
  
  // optional string completed_at = 3;
  inline bool has_completed_at() const;
  inline void clear_completed_at();
  inline const ::std::string& completed_at() const;
  inline void set_completed_at(const ::std::string& value);
  inline void set_completed_at(const char* value);
  inline ::std::string* mutable_completed_at();
  
  // optional uint64 total_num_urls = 4;
  inline bool has_total_num_urls() const;
  inline void clear_total_num_urls();
  inline ::google::protobuf::uint64 total_num_urls() const;
  inline void set_total_num_urls(::google::protobuf::uint64 value);
  
  // repeated .HoneyClient.Message.Url url = 5;
  inline int url_size() const;
  inline void clear_url();
  inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Url >& url() const;
  inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Url >* mutable_url();
  inline const ::HoneyClient::Message_Url& url(int index) const;
  inline ::HoneyClient::Message_Url* mutable_url(int index);
  inline ::HoneyClient::Message_Url* add_url();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* uuid_;
  static const ::std::string _default_uuid_;
  ::std::string* created_at_;
  static const ::std::string _default_created_at_;
  ::std::string* completed_at_;
  static const ::std::string _default_completed_at_;
  ::google::protobuf::uint64 total_num_urls_;
  ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Url > url_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Job* default_instance_;
};
// -------------------------------------------------------------------

class Message_Firewall_Command : public ::google::protobuf::Message {
 public:
  Message_Firewall_Command();
  virtual ~Message_Firewall_Command();
  
  Message_Firewall_Command(const Message_Firewall_Command& from);
  
  inline Message_Firewall_Command& operator=(const Message_Firewall_Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Firewall_Command& default_instance();
  void Swap(Message_Firewall_Command* other);
  
  // implements Message ----------------------------------------------
  
  Message_Firewall_Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Firewall_Command& from);
  void MergeFrom(const Message_Firewall_Command& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Firewall_Command_ActionType ActionType;
  static const ActionType UNKNOWN = Message_Firewall_Command_ActionType_UNKNOWN;
  static const ActionType DENY_ALL = Message_Firewall_Command_ActionType_DENY_ALL;
  static const ActionType DENY_VM = Message_Firewall_Command_ActionType_DENY_VM;
  static const ActionType ALLOW_VM = Message_Firewall_Command_ActionType_ALLOW_VM;
  static const ActionType ALLOW_ALL = Message_Firewall_Command_ActionType_ALLOW_ALL;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Message_Firewall_Command_ActionType_descriptor();
  }
  static inline bool ActionType_IsValid(int value) {
    return Message_Firewall_Command_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Message_Firewall_Command_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Message_Firewall_Command_ActionType_ActionType_MAX;
  
  typedef Message_Firewall_Command_ResponseType ResponseType;
  static const ResponseType ERROR = Message_Firewall_Command_ResponseType_ERROR;
  static const ResponseType OK = Message_Firewall_Command_ResponseType_OK;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Message_Firewall_Command_ResponseType_descriptor();
  }
  static inline bool ResponseType_IsValid(int value) {
    return Message_Firewall_Command_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Message_Firewall_Command_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Message_Firewall_Command_ResponseType_ResponseType_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .HoneyClient.Message.Firewall.Command.ActionType action = 1 [default = UNKNOWN];
  inline bool has_action() const;
  inline void clear_action();
  inline ::HoneyClient::Message_Firewall_Command_ActionType action() const;
  inline void set_action(::HoneyClient::Message_Firewall_Command_ActionType value);
  
  // optional .HoneyClient.Message.Firewall.Command.ResponseType response = 2 [default = ERROR];
  inline bool has_response() const;
  inline void clear_response();
  inline ::HoneyClient::Message_Firewall_Command_ResponseType response() const;
  inline void set_response(::HoneyClient::Message_Firewall_Command_ResponseType value);
  
  // optional string err_message = 3;
  inline bool has_err_message() const;
  inline void clear_err_message();
  inline const ::std::string& err_message() const;
  inline void set_err_message(const ::std::string& value);
  inline void set_err_message(const char* value);
  inline ::std::string* mutable_err_message();
  
  // optional string chain_name = 4;
  inline bool has_chain_name() const;
  inline void clear_chain_name();
  inline const ::std::string& chain_name() const;
  inline void set_chain_name(const ::std::string& value);
  inline void set_chain_name(const char* value);
  inline ::std::string* mutable_chain_name();
  
  // optional string mac_address = 5;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline ::std::string* mutable_mac_address();
  
  // optional string ip_address = 6;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline ::std::string* mutable_ip_address();
  
  // optional string protocol = 7;
  inline bool has_protocol() const;
  inline void clear_protocol();
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline ::std::string* mutable_protocol();
  
  // repeated uint32 port = 8;
  inline int port_size() const;
  inline void clear_port();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >& port() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >* mutable_port();
  inline ::google::protobuf::uint32 port(int index) const;
  inline void set_port(int index, ::google::protobuf::uint32 value);
  inline void add_port(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int action_;
  int response_;
  ::std::string* err_message_;
  static const ::std::string _default_err_message_;
  ::std::string* chain_name_;
  static const ::std::string _default_chain_name_;
  ::std::string* mac_address_;
  static const ::std::string _default_mac_address_;
  ::std::string* ip_address_;
  static const ::std::string _default_ip_address_;
  ::std::string* protocol_;
  static const ::std::string _default_protocol_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > port_;
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Firewall_Command* default_instance_;
};
// -------------------------------------------------------------------

class Message_Firewall : public ::google::protobuf::Message {
 public:
  Message_Firewall();
  virtual ~Message_Firewall();
  
  Message_Firewall(const Message_Firewall& from);
  
  inline Message_Firewall& operator=(const Message_Firewall& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Firewall& default_instance();
  void Swap(Message_Firewall* other);
  
  // implements Message ----------------------------------------------
  
  Message_Firewall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Firewall& from);
  void MergeFrom(const Message_Firewall& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Firewall_Command Command;
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message_Firewall* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Client Client;
  typedef Message_File File;
  typedef Message_Registry Registry;
  typedef Message_Process Process;
  typedef Message_Fingerprint Fingerprint;
  typedef Message_Url Url;
  typedef Message_Job Job;
  typedef Message_Firewall Firewall;
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_message_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Message_Client

// required string vm_name = 1;
inline bool Message_Client::has_vm_name() const {
  return _has_bit(0);
}
inline void Message_Client::clear_vm_name() {
  if (vm_name_ != &_default_vm_name_) {
    vm_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_Client::vm_name() const {
  return *vm_name_;
}
inline void Message_Client::set_vm_name(const ::std::string& value) {
  _set_bit(0);
  if (vm_name_ == &_default_vm_name_) {
    vm_name_ = new ::std::string;
  }
  vm_name_->assign(value);
}
inline void Message_Client::set_vm_name(const char* value) {
  _set_bit(0);
  if (vm_name_ == &_default_vm_name_) {
    vm_name_ = new ::std::string;
  }
  vm_name_->assign(value);
}
inline ::std::string* Message_Client::mutable_vm_name() {
  _set_bit(0);
  if (vm_name_ == &_default_vm_name_) {
    vm_name_ = new ::std::string;
  }
  return vm_name_;
}

// required string snapshot_name = 2;
inline bool Message_Client::has_snapshot_name() const {
  return _has_bit(1);
}
inline void Message_Client::clear_snapshot_name() {
  if (snapshot_name_ != &_default_snapshot_name_) {
    snapshot_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Message_Client::snapshot_name() const {
  return *snapshot_name_;
}
inline void Message_Client::set_snapshot_name(const ::std::string& value) {
  _set_bit(1);
  if (snapshot_name_ == &_default_snapshot_name_) {
    snapshot_name_ = new ::std::string;
  }
  snapshot_name_->assign(value);
}
inline void Message_Client::set_snapshot_name(const char* value) {
  _set_bit(1);
  if (snapshot_name_ == &_default_snapshot_name_) {
    snapshot_name_ = new ::std::string;
  }
  snapshot_name_->assign(value);
}
inline ::std::string* Message_Client::mutable_snapshot_name() {
  _set_bit(1);
  if (snapshot_name_ == &_default_snapshot_name_) {
    snapshot_name_ = new ::std::string;
  }
  return snapshot_name_;
}

// optional string status = 3;
inline bool Message_Client::has_status() const {
  return _has_bit(2);
}
inline void Message_Client::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_Client::status() const {
  return *status_;
}
inline void Message_Client::set_status(const ::std::string& value) {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void Message_Client::set_status(const char* value) {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline ::std::string* Message_Client::mutable_status() {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// optional string start_at = 4;
inline bool Message_Client::has_start_at() const {
  return _has_bit(3);
}
inline void Message_Client::clear_start_at() {
  if (start_at_ != &_default_start_at_) {
    start_at_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Message_Client::start_at() const {
  return *start_at_;
}
inline void Message_Client::set_start_at(const ::std::string& value) {
  _set_bit(3);
  if (start_at_ == &_default_start_at_) {
    start_at_ = new ::std::string;
  }
  start_at_->assign(value);
}
inline void Message_Client::set_start_at(const char* value) {
  _set_bit(3);
  if (start_at_ == &_default_start_at_) {
    start_at_ = new ::std::string;
  }
  start_at_->assign(value);
}
inline ::std::string* Message_Client::mutable_start_at() {
  _set_bit(3);
  if (start_at_ == &_default_start_at_) {
    start_at_ = new ::std::string;
  }
  return start_at_;
}

// optional string compromise_at = 5;
inline bool Message_Client::has_compromise_at() const {
  return _has_bit(4);
}
inline void Message_Client::clear_compromise_at() {
  if (compromise_at_ != &_default_compromise_at_) {
    compromise_at_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Message_Client::compromise_at() const {
  return *compromise_at_;
}
inline void Message_Client::set_compromise_at(const ::std::string& value) {
  _set_bit(4);
  if (compromise_at_ == &_default_compromise_at_) {
    compromise_at_ = new ::std::string;
  }
  compromise_at_->assign(value);
}
inline void Message_Client::set_compromise_at(const char* value) {
  _set_bit(4);
  if (compromise_at_ == &_default_compromise_at_) {
    compromise_at_ = new ::std::string;
  }
  compromise_at_->assign(value);
}
inline ::std::string* Message_Client::mutable_compromise_at() {
  _set_bit(4);
  if (compromise_at_ == &_default_compromise_at_) {
    compromise_at_ = new ::std::string;
  }
  return compromise_at_;
}

// -------------------------------------------------------------------

// Message_File_Content

// required uint64 size = 1;
inline bool Message_File_Content::has_size() const {
  return _has_bit(0);
}
inline void Message_File_Content::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Message_File_Content::size() const {
  return size_;
}
inline void Message_File_Content::set_size(::google::protobuf::uint64 value) {
  _set_bit(0);
  size_ = value;
}

// required string md5 = 2;
inline bool Message_File_Content::has_md5() const {
  return _has_bit(1);
}
inline void Message_File_Content::clear_md5() {
  if (md5_ != &_default_md5_) {
    md5_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Message_File_Content::md5() const {
  return *md5_;
}
inline void Message_File_Content::set_md5(const ::std::string& value) {
  _set_bit(1);
  if (md5_ == &_default_md5_) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void Message_File_Content::set_md5(const char* value) {
  _set_bit(1);
  if (md5_ == &_default_md5_) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline ::std::string* Message_File_Content::mutable_md5() {
  _set_bit(1);
  if (md5_ == &_default_md5_) {
    md5_ = new ::std::string;
  }
  return md5_;
}

// required string sha1 = 3;
inline bool Message_File_Content::has_sha1() const {
  return _has_bit(2);
}
inline void Message_File_Content::clear_sha1() {
  if (sha1_ != &_default_sha1_) {
    sha1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_File_Content::sha1() const {
  return *sha1_;
}
inline void Message_File_Content::set_sha1(const ::std::string& value) {
  _set_bit(2);
  if (sha1_ == &_default_sha1_) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void Message_File_Content::set_sha1(const char* value) {
  _set_bit(2);
  if (sha1_ == &_default_sha1_) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline ::std::string* Message_File_Content::mutable_sha1() {
  _set_bit(2);
  if (sha1_ == &_default_sha1_) {
    sha1_ = new ::std::string;
  }
  return sha1_;
}

// required string mime_type = 4;
inline bool Message_File_Content::has_mime_type() const {
  return _has_bit(3);
}
inline void Message_File_Content::clear_mime_type() {
  if (mime_type_ != &_default_mime_type_) {
    mime_type_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Message_File_Content::mime_type() const {
  return *mime_type_;
}
inline void Message_File_Content::set_mime_type(const ::std::string& value) {
  _set_bit(3);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void Message_File_Content::set_mime_type(const char* value) {
  _set_bit(3);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline ::std::string* Message_File_Content::mutable_mime_type() {
  _set_bit(3);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}

// -------------------------------------------------------------------

// Message_File

// required string time_at = 1;
inline bool Message_File::has_time_at() const {
  return _has_bit(0);
}
inline void Message_File::clear_time_at() {
  if (time_at_ != &_default_time_at_) {
    time_at_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_File::time_at() const {
  return *time_at_;
}
inline void Message_File::set_time_at(const ::std::string& value) {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  time_at_->assign(value);
}
inline void Message_File::set_time_at(const char* value) {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  time_at_->assign(value);
}
inline ::std::string* Message_File::mutable_time_at() {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  return time_at_;
}

// required string name = 2;
inline bool Message_File::has_name() const {
  return _has_bit(1);
}
inline void Message_File::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Message_File::name() const {
  return *name_;
}
inline void Message_File::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Message_File::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* Message_File::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string event = 3;
inline bool Message_File::has_event() const {
  return _has_bit(2);
}
inline void Message_File::clear_event() {
  if (event_ != &_default_event_) {
    event_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_File::event() const {
  return *event_;
}
inline void Message_File::set_event(const ::std::string& value) {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void Message_File::set_event(const char* value) {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline ::std::string* Message_File::mutable_event() {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  return event_;
}

// required .HoneyClient.Message.File.Content content = 4;
inline bool Message_File::has_content() const {
  return _has_bit(3);
}
inline void Message_File::clear_content() {
  if (content_ != NULL) content_->::HoneyClient::Message_File_Content::Clear();
  _clear_bit(3);
}
inline const ::HoneyClient::Message_File_Content& Message_File::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::HoneyClient::Message_File_Content* Message_File::mutable_content() {
  _set_bit(3);
  if (content_ == NULL) content_ = new ::HoneyClient::Message_File_Content;
  return content_;
}

// -------------------------------------------------------------------

// Message_Registry

// required string time_at = 1;
inline bool Message_Registry::has_time_at() const {
  return _has_bit(0);
}
inline void Message_Registry::clear_time_at() {
  if (time_at_ != &_default_time_at_) {
    time_at_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_Registry::time_at() const {
  return *time_at_;
}
inline void Message_Registry::set_time_at(const ::std::string& value) {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  time_at_->assign(value);
}
inline void Message_Registry::set_time_at(const char* value) {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  time_at_->assign(value);
}
inline ::std::string* Message_Registry::mutable_time_at() {
  _set_bit(0);
  if (time_at_ == &_default_time_at_) {
    time_at_ = new ::std::string;
  }
  return time_at_;
}

// required string name = 2;
inline bool Message_Registry::has_name() const {
  return _has_bit(1);
}
inline void Message_Registry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Message_Registry::name() const {
  return *name_;
}
inline void Message_Registry::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Message_Registry::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* Message_Registry::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string event = 3;
inline bool Message_Registry::has_event() const {
  return _has_bit(2);
}
inline void Message_Registry::clear_event() {
  if (event_ != &_default_event_) {
    event_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_Registry::event() const {
  return *event_;
}
inline void Message_Registry::set_event(const ::std::string& value) {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void Message_Registry::set_event(const char* value) {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline ::std::string* Message_Registry::mutable_event() {
  _set_bit(2);
  if (event_ == &_default_event_) {
    event_ = new ::std::string;
  }
  return event_;
}

// optional string value = 5;
inline bool Message_Registry::has_value() const {
  return _has_bit(3);
}
inline void Message_Registry::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Message_Registry::value() const {
  return *value_;
}
inline void Message_Registry::set_value(const ::std::string& value) {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Message_Registry::set_value(const char* value) {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline ::std::string* Message_Registry::mutable_value() {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional string value_name = 6;
inline bool Message_Registry::has_value_name() const {
  return _has_bit(4);
}
inline void Message_Registry::clear_value_name() {
  if (value_name_ != &_default_value_name_) {
    value_name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Message_Registry::value_name() const {
  return *value_name_;
}
inline void Message_Registry::set_value_name(const ::std::string& value) {
  _set_bit(4);
  if (value_name_ == &_default_value_name_) {
    value_name_ = new ::std::string;
  }
  value_name_->assign(value);
}
inline void Message_Registry::set_value_name(const char* value) {
  _set_bit(4);
  if (value_name_ == &_default_value_name_) {
    value_name_ = new ::std::string;
  }
  value_name_->assign(value);
}
inline ::std::string* Message_Registry::mutable_value_name() {
  _set_bit(4);
  if (value_name_ == &_default_value_name_) {
    value_name_ = new ::std::string;
  }
  return value_name_;
}

// optional string value_type = 7;
inline bool Message_Registry::has_value_type() const {
  return _has_bit(5);
}
inline void Message_Registry::clear_value_type() {
  if (value_type_ != &_default_value_type_) {
    value_type_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Message_Registry::value_type() const {
  return *value_type_;
}
inline void Message_Registry::set_value_type(const ::std::string& value) {
  _set_bit(5);
  if (value_type_ == &_default_value_type_) {
    value_type_ = new ::std::string;
  }
  value_type_->assign(value);
}
inline void Message_Registry::set_value_type(const char* value) {
  _set_bit(5);
  if (value_type_ == &_default_value_type_) {
    value_type_ = new ::std::string;
  }
  value_type_->assign(value);
}
inline ::std::string* Message_Registry::mutable_value_type() {
  _set_bit(5);
  if (value_type_ == &_default_value_type_) {
    value_type_ = new ::std::string;
  }
  return value_type_;
}

// -------------------------------------------------------------------

// Message_Process

// required string name = 1;
inline bool Message_Process::has_name() const {
  return _has_bit(0);
}
inline void Message_Process::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_Process::name() const {
  return *name_;
}
inline void Message_Process::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Message_Process::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* Message_Process::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required uint64 pid = 2;
inline bool Message_Process::has_pid() const {
  return _has_bit(1);
}
inline void Message_Process::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 Message_Process::pid() const {
  return pid_;
}
inline void Message_Process::set_pid(::google::protobuf::uint64 value) {
  _set_bit(1);
  pid_ = value;
}

// repeated .HoneyClient.Message.File file = 3;
inline int Message_Process::file_size() const {
  return file_.size();
}
inline void Message_Process::clear_file() {
  file_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_File >&
Message_Process::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_File >*
Message_Process::mutable_file() {
  return &file_;
}
inline const ::HoneyClient::Message_File& Message_Process::file(int index) const {
  return file_.Get(index);
}
inline ::HoneyClient::Message_File* Message_Process::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::HoneyClient::Message_File* Message_Process::add_file() {
  return file_.Add();
}

// repeated .HoneyClient.Message.Registry registry = 4;
inline int Message_Process::registry_size() const {
  return registry_.size();
}
inline void Message_Process::clear_registry() {
  registry_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Registry >&
Message_Process::registry() const {
  return registry_;
}
inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Registry >*
Message_Process::mutable_registry() {
  return &registry_;
}
inline const ::HoneyClient::Message_Registry& Message_Process::registry(int index) const {
  return registry_.Get(index);
}
inline ::HoneyClient::Message_Registry* Message_Process::mutable_registry(int index) {
  return registry_.Mutable(index);
}
inline ::HoneyClient::Message_Registry* Message_Process::add_registry() {
  return registry_.Add();
}

// -------------------------------------------------------------------

// Message_Fingerprint

// repeated .HoneyClient.Message.Process process = 1;
inline int Message_Fingerprint::process_size() const {
  return process_.size();
}
inline void Message_Fingerprint::clear_process() {
  process_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Process >&
Message_Fingerprint::process() const {
  return process_;
}
inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Process >*
Message_Fingerprint::mutable_process() {
  return &process_;
}
inline const ::HoneyClient::Message_Process& Message_Fingerprint::process(int index) const {
  return process_.Get(index);
}
inline ::HoneyClient::Message_Process* Message_Fingerprint::mutable_process(int index) {
  return process_.Mutable(index);
}
inline ::HoneyClient::Message_Process* Message_Fingerprint::add_process() {
  return process_.Add();
}

// -------------------------------------------------------------------

// Message_Url

// required string name = 1;
inline bool Message_Url::has_name() const {
  return _has_bit(0);
}
inline void Message_Url::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_Url::name() const {
  return *name_;
}
inline void Message_Url::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Message_Url::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* Message_Url::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .HoneyClient.Message.Url.Status status = 2 [default = NOT_VISITED];
inline bool Message_Url::has_status() const {
  return _has_bit(1);
}
inline void Message_Url::clear_status() {
  status_ = 1;
  _clear_bit(1);
}
inline ::HoneyClient::Message_Url_Status Message_Url::status() const {
  return static_cast< ::HoneyClient::Message_Url_Status >(status_);
}
inline void Message_Url::set_status(::HoneyClient::Message_Url_Status value) {
  GOOGLE_DCHECK(::HoneyClient::Message_Url_Status_IsValid(value));
  _set_bit(1);
  status_ = value;
}

// optional .HoneyClient.Message.Client client = 3;
inline bool Message_Url::has_client() const {
  return _has_bit(2);
}
inline void Message_Url::clear_client() {
  if (client_ != NULL) client_->::HoneyClient::Message_Client::Clear();
  _clear_bit(2);
}
inline const ::HoneyClient::Message_Client& Message_Url::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::HoneyClient::Message_Client* Message_Url::mutable_client() {
  _set_bit(2);
  if (client_ == NULL) client_ = new ::HoneyClient::Message_Client;
  return client_;
}

// optional .HoneyClient.Message.Fingerprint fingerprint = 4;
inline bool Message_Url::has_fingerprint() const {
  return _has_bit(3);
}
inline void Message_Url::clear_fingerprint() {
  if (fingerprint_ != NULL) fingerprint_->::HoneyClient::Message_Fingerprint::Clear();
  _clear_bit(3);
}
inline const ::HoneyClient::Message_Fingerprint& Message_Url::fingerprint() const {
  return fingerprint_ != NULL ? *fingerprint_ : *default_instance_->fingerprint_;
}
inline ::HoneyClient::Message_Fingerprint* Message_Url::mutable_fingerprint() {
  _set_bit(3);
  if (fingerprint_ == NULL) fingerprint_ = new ::HoneyClient::Message_Fingerprint;
  return fingerprint_;
}

// -------------------------------------------------------------------

// Message_Job

// required string uuid = 1;
inline bool Message_Job::has_uuid() const {
  return _has_bit(0);
}
inline void Message_Job::clear_uuid() {
  if (uuid_ != &_default_uuid_) {
    uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Message_Job::uuid() const {
  return *uuid_;
}
inline void Message_Job::set_uuid(const ::std::string& value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Message_Job::set_uuid(const char* value) {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline ::std::string* Message_Job::mutable_uuid() {
  _set_bit(0);
  if (uuid_ == &_default_uuid_) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}

// optional string created_at = 2;
inline bool Message_Job::has_created_at() const {
  return _has_bit(1);
}
inline void Message_Job::clear_created_at() {
  if (created_at_ != &_default_created_at_) {
    created_at_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Message_Job::created_at() const {
  return *created_at_;
}
inline void Message_Job::set_created_at(const ::std::string& value) {
  _set_bit(1);
  if (created_at_ == &_default_created_at_) {
    created_at_ = new ::std::string;
  }
  created_at_->assign(value);
}
inline void Message_Job::set_created_at(const char* value) {
  _set_bit(1);
  if (created_at_ == &_default_created_at_) {
    created_at_ = new ::std::string;
  }
  created_at_->assign(value);
}
inline ::std::string* Message_Job::mutable_created_at() {
  _set_bit(1);
  if (created_at_ == &_default_created_at_) {
    created_at_ = new ::std::string;
  }
  return created_at_;
}

// optional string completed_at = 3;
inline bool Message_Job::has_completed_at() const {
  return _has_bit(2);
}
inline void Message_Job::clear_completed_at() {
  if (completed_at_ != &_default_completed_at_) {
    completed_at_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_Job::completed_at() const {
  return *completed_at_;
}
inline void Message_Job::set_completed_at(const ::std::string& value) {
  _set_bit(2);
  if (completed_at_ == &_default_completed_at_) {
    completed_at_ = new ::std::string;
  }
  completed_at_->assign(value);
}
inline void Message_Job::set_completed_at(const char* value) {
  _set_bit(2);
  if (completed_at_ == &_default_completed_at_) {
    completed_at_ = new ::std::string;
  }
  completed_at_->assign(value);
}
inline ::std::string* Message_Job::mutable_completed_at() {
  _set_bit(2);
  if (completed_at_ == &_default_completed_at_) {
    completed_at_ = new ::std::string;
  }
  return completed_at_;
}

// optional uint64 total_num_urls = 4;
inline bool Message_Job::has_total_num_urls() const {
  return _has_bit(3);
}
inline void Message_Job::clear_total_num_urls() {
  total_num_urls_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 Message_Job::total_num_urls() const {
  return total_num_urls_;
}
inline void Message_Job::set_total_num_urls(::google::protobuf::uint64 value) {
  _set_bit(3);
  total_num_urls_ = value;
}

// repeated .HoneyClient.Message.Url url = 5;
inline int Message_Job::url_size() const {
  return url_.size();
}
inline void Message_Job::clear_url() {
  url_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Url >&
Message_Job::url() const {
  return url_;
}
inline ::google::protobuf::RepeatedPtrField< ::HoneyClient::Message_Url >*
Message_Job::mutable_url() {
  return &url_;
}
inline const ::HoneyClient::Message_Url& Message_Job::url(int index) const {
  return url_.Get(index);
}
inline ::HoneyClient::Message_Url* Message_Job::mutable_url(int index) {
  return url_.Mutable(index);
}
inline ::HoneyClient::Message_Url* Message_Job::add_url() {
  return url_.Add();
}

// -------------------------------------------------------------------

// Message_Firewall_Command

// required .HoneyClient.Message.Firewall.Command.ActionType action = 1 [default = UNKNOWN];
inline bool Message_Firewall_Command::has_action() const {
  return _has_bit(0);
}
inline void Message_Firewall_Command::clear_action() {
  action_ = 1;
  _clear_bit(0);
}
inline ::HoneyClient::Message_Firewall_Command_ActionType Message_Firewall_Command::action() const {
  return static_cast< ::HoneyClient::Message_Firewall_Command_ActionType >(action_);
}
inline void Message_Firewall_Command::set_action(::HoneyClient::Message_Firewall_Command_ActionType value) {
  GOOGLE_DCHECK(::HoneyClient::Message_Firewall_Command_ActionType_IsValid(value));
  _set_bit(0);
  action_ = value;
}

// optional .HoneyClient.Message.Firewall.Command.ResponseType response = 2 [default = ERROR];
inline bool Message_Firewall_Command::has_response() const {
  return _has_bit(1);
}
inline void Message_Firewall_Command::clear_response() {
  response_ = 1;
  _clear_bit(1);
}
inline ::HoneyClient::Message_Firewall_Command_ResponseType Message_Firewall_Command::response() const {
  return static_cast< ::HoneyClient::Message_Firewall_Command_ResponseType >(response_);
}
inline void Message_Firewall_Command::set_response(::HoneyClient::Message_Firewall_Command_ResponseType value) {
  GOOGLE_DCHECK(::HoneyClient::Message_Firewall_Command_ResponseType_IsValid(value));
  _set_bit(1);
  response_ = value;
}

// optional string err_message = 3;
inline bool Message_Firewall_Command::has_err_message() const {
  return _has_bit(2);
}
inline void Message_Firewall_Command::clear_err_message() {
  if (err_message_ != &_default_err_message_) {
    err_message_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Message_Firewall_Command::err_message() const {
  return *err_message_;
}
inline void Message_Firewall_Command::set_err_message(const ::std::string& value) {
  _set_bit(2);
  if (err_message_ == &_default_err_message_) {
    err_message_ = new ::std::string;
  }
  err_message_->assign(value);
}
inline void Message_Firewall_Command::set_err_message(const char* value) {
  _set_bit(2);
  if (err_message_ == &_default_err_message_) {
    err_message_ = new ::std::string;
  }
  err_message_->assign(value);
}
inline ::std::string* Message_Firewall_Command::mutable_err_message() {
  _set_bit(2);
  if (err_message_ == &_default_err_message_) {
    err_message_ = new ::std::string;
  }
  return err_message_;
}

// optional string chain_name = 4;
inline bool Message_Firewall_Command::has_chain_name() const {
  return _has_bit(3);
}
inline void Message_Firewall_Command::clear_chain_name() {
  if (chain_name_ != &_default_chain_name_) {
    chain_name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Message_Firewall_Command::chain_name() const {
  return *chain_name_;
}
inline void Message_Firewall_Command::set_chain_name(const ::std::string& value) {
  _set_bit(3);
  if (chain_name_ == &_default_chain_name_) {
    chain_name_ = new ::std::string;
  }
  chain_name_->assign(value);
}
inline void Message_Firewall_Command::set_chain_name(const char* value) {
  _set_bit(3);
  if (chain_name_ == &_default_chain_name_) {
    chain_name_ = new ::std::string;
  }
  chain_name_->assign(value);
}
inline ::std::string* Message_Firewall_Command::mutable_chain_name() {
  _set_bit(3);
  if (chain_name_ == &_default_chain_name_) {
    chain_name_ = new ::std::string;
  }
  return chain_name_;
}

// optional string mac_address = 5;
inline bool Message_Firewall_Command::has_mac_address() const {
  return _has_bit(4);
}
inline void Message_Firewall_Command::clear_mac_address() {
  if (mac_address_ != &_default_mac_address_) {
    mac_address_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Message_Firewall_Command::mac_address() const {
  return *mac_address_;
}
inline void Message_Firewall_Command::set_mac_address(const ::std::string& value) {
  _set_bit(4);
  if (mac_address_ == &_default_mac_address_) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void Message_Firewall_Command::set_mac_address(const char* value) {
  _set_bit(4);
  if (mac_address_ == &_default_mac_address_) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline ::std::string* Message_Firewall_Command::mutable_mac_address() {
  _set_bit(4);
  if (mac_address_ == &_default_mac_address_) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}

// optional string ip_address = 6;
inline bool Message_Firewall_Command::has_ip_address() const {
  return _has_bit(5);
}
inline void Message_Firewall_Command::clear_ip_address() {
  if (ip_address_ != &_default_ip_address_) {
    ip_address_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Message_Firewall_Command::ip_address() const {
  return *ip_address_;
}
inline void Message_Firewall_Command::set_ip_address(const ::std::string& value) {
  _set_bit(5);
  if (ip_address_ == &_default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void Message_Firewall_Command::set_ip_address(const char* value) {
  _set_bit(5);
  if (ip_address_ == &_default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline ::std::string* Message_Firewall_Command::mutable_ip_address() {
  _set_bit(5);
  if (ip_address_ == &_default_ip_address_) {
    ip_address_ = new ::std::string;
  }
  return ip_address_;
}

// optional string protocol = 7;
inline bool Message_Firewall_Command::has_protocol() const {
  return _has_bit(6);
}
inline void Message_Firewall_Command::clear_protocol() {
  if (protocol_ != &_default_protocol_) {
    protocol_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Message_Firewall_Command::protocol() const {
  return *protocol_;
}
inline void Message_Firewall_Command::set_protocol(const ::std::string& value) {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Message_Firewall_Command::set_protocol(const char* value) {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline ::std::string* Message_Firewall_Command::mutable_protocol() {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}

// repeated uint32 port = 8;
inline int Message_Firewall_Command::port_size() const {
  return port_.size();
}
inline void Message_Firewall_Command::clear_port() {
  port_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Message_Firewall_Command::port() const {
  return port_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Message_Firewall_Command::mutable_port() {
  return &port_;
}
inline ::google::protobuf::uint32 Message_Firewall_Command::port(int index) const {
  return port_.Get(index);
}
inline void Message_Firewall_Command::set_port(int index, ::google::protobuf::uint32 value) {
  port_.Set(index, value);
}
inline void Message_Firewall_Command::add_port(::google::protobuf::uint32 value) {
  port_.Add(value);
}

// -------------------------------------------------------------------

// Message_Firewall

// -------------------------------------------------------------------

// Message


}  // namespace HoneyClient
#endif  // PROTOBUF_message_2eproto__INCLUDED
